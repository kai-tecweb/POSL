# POSL コーディング規約・標準

## 基本原則

- 常に日本語で分かりやすい言葉を選び、丁寧な表現を心がけます。
- 初心者にも分かりやすく説明します。専門用語はできるだけ避け、必要な場合は簡単な説明を加えます。
- 常に励ましの言葉を添えます。学習意欲が高まる工夫をします。
- 質問の意図が理解できない場合は、その旨を伝えます。
- コードの重複を避け、反復とモジュール化を優先します。
- 補助動詞（`isLoading`、`hasError`など）を用いた説明的な変数名を使用します。
- ROROパターン（Receive an Object, Return an Object: オブジェクトを受け取り、オブジェクトを返すパターン）を必要に応じて使用します。

## 品質とセキュリティ

- 提案を行う際は、変更を個別のステップに分解し、各段階で小さなテストを提案して進行状況を確認します。
- コードを書く前に、既存のコードを深くレビューし、動作を記述します。
- ソリューションのホスト、管理、監視、保守方法を考慮し、運用上の懸念を強調します。
- フィードバックに基づいてアプローチを調整し、提案がプロジェクトのニーズに合わせて進化するようにします。
- データを危険にさらしたり、新たな脆弱性をもたらさないように、あらゆる段階で確認します。
- 潜在的なセキュリティリスクがある場合は、追加のレビューを行います。

## ドキュメント・コメント

- コード例を示す際は、各行の目的を詳細なコメントで説明し、実行結果も示します。
- 良いコーディングの習慣やベストプラクティスがあるなら、折に触れアドバイスをします。
- エラーメッセージは、エラーメッセージの意味を解説し、デバッグの手順を段階的に説明します。
- 複雑な問題は、小さなステップに分割し一つずつ丁寧に解説します。

## 専門領域の重視

- **AI活用**: OpenAI GPT-4による高品質なコンテンツ生成を実現します。
- **X (Twitter) API統合**: X API v2による自動投稿機能を実装します。
- **トレンド分析**: Google/Yahoo Trends APIによるトレンド情報の取得と活用を実現します。
- **自動化**: node-cronによる定期実行とスケジューリング機能を実装します。
- **AWSインフラ**: EC2、RDS、S3、CloudWatchを活用したスケーラブルなインフラを構築します。

## バックエンド（Node.js + Express.js）規約

### 基本原則

- Node.js 18.x以上を使用します。
- Express.jsを使用してRESTful APIを構築します。
- TypeScriptまたはJavaScript（CommonJS）を使用します。
- 環境変数は`dotenv`を使用して管理します。

### ファイル構成

```
backend/
├── src/                    # ソースコード（TypeScript使用時）
├── simple_final_api.js     # メインAPIサーバー（Express.js）
├── package.json
├── ecosystem.config.js      # PM2設定
└── .env                     # 環境変数（.gitignoreに含める）
```

### 命名規則

- **ファイル名**: kebab-caseを使用します（例：`post-service.js`、`user-controller.js`）。
- **クラス名**: PascalCaseを使用します（例：`PostService`、`UserController`）。
- **関数名・メソッド名**: camelCaseを使用します（例：`getPostLogs`、`savePostLog`）。
- **変数名**: camelCaseを使用します（例：`postData`、`userId`）。
- **定数名**: UPPER_SNAKE_CASEを使用します（例：`MAX_POST_LENGTH`、`DEFAULT_TIMEZONE`）。
- **プライベート変数・関数**: 先頭にアンダースコアを付けます（例：`_privateMethod`、`_internalData`）。

### コードスタイル

- セミコロンは必ず使用します。
- インデントは2スペースを使用します。
- 文字列はシングルクォート（`'`）を使用します。
- オブジェクトや配列の最後の要素の後にカンマを付けます（trailing comma）。
- 1行の長さは80文字を目安とします（Prettier設定に従う）。

### API設計

- RESTfulな設計原則を遵守します。
- 統一されたAPIレスポンス形式を使用します：
  ```javascript
  {
    success: boolean,
    data?: any,
    error?: string,
    message?: string
  }
  ```
- 適切なHTTPステータスコードを返します：
  - `200`: 成功
  - `201`: 作成成功
  - `400`: バリデーションエラー
  - `401`: 認証エラー
  - `403`: 権限エラー
  - `404`: リソースが見つからない
  - `500`: サーバーエラー

### エラーハンドリング

- すべての非同期処理で`try-catch`を使用します。
- エラーログは詳細に記録します（`console.error`を使用）。
- エラーメッセージはユーザーに分かりやすい形式で返します。
- 機密情報（パスワード、APIキーなど）はエラーメッセージに含めません。

### データベース

- MySQL 8.0（RDS）を使用します。
- `mysql2/promise`を使用して非同期処理を実装します。
- 接続は必ず`finally`ブロックでクローズします。
- SQLインジェクション対策として、必ずプリペアドステートメントを使用します。

### 環境変数

- 環境変数は`.env`ファイルで管理します。
- `.env.example`ファイルを作成し、必要な環境変数を記載します。
- 本番環境では環境変数を直接設定します（`.env`ファイルは使用しない）。

### ログ出力

- ログレベルに応じて適切なメソッドを使用します：
  - `console.log()`: 通常の情報
  - `console.warn()`: 警告
  - `console.error()`: エラー
- 本番環境では構造化ログ（JSON形式）を推奨します。

### 例

```javascript
// ✅ 良い例
const getPostLogs = async (userId, limit = 10) => {
  let connection;
  try {
    connection = await mysql.createConnection({
      host: process.env.MYSQL_HOST,
      port: parseInt(process.env.MYSQL_PORT),
      user: process.env.MYSQL_USER,
      password: process.env.MYSQL_PASSWORD,
      database: process.env.MYSQL_DATABASE,
    });

    const [rows] = await connection.execute(
      'SELECT * FROM post_logs WHERE user_id = ? ORDER BY created_at DESC LIMIT ?',
      [userId, limit]
    );

    return {
      success: true,
      data: rows,
    };
  } catch (error) {
    console.error('❌ 投稿ログ取得エラー:', error);
    return {
      success: false,
      error: error.message,
    };
  } finally {
    if (connection) {
      await connection.end();
    }
  }
};

// ❌ 悪い例
const getPosts = async (id, lim) => {
  const conn = await mysql.createConnection({...});
  const [r] = await conn.execute('SELECT * FROM post_logs WHERE user_id = ' + id);
  return r;
};
```

## フロントエンド（Next.js 14 + TypeScript + Tailwind CSS）規約

### 基本原則

- Next.js 14のApp Routerを使用します。
- TypeScriptを使用し、型安全性を確保します。
- Tailwind CSSを使用してスタイリングを行います。
- React Server Components（RSC）とClient Componentsを適切に使い分けます。

### ファイル構成

```
frontend/
├── src/
│   ├── app/                 # Next.js App Router ページ
│   │   ├── layout.tsx       # ルートレイアウト
│   │   ├── page.tsx         # ルートページ
│   │   ├── dashboard/       # ダッシュボードページ
│   │   └── settings/         # 設定ページ
│   ├── components/          # Reactコンポーネント
│   │   ├── ui/              # UI基本コンポーネント
│   │   ├── Layout.tsx        # レイアウトコンポーネント
│   │   └── ...
│   ├── hooks/               # カスタムフック
│   ├── store/               # 状態管理（Zustand）
│   ├── types/               # TypeScript型定義
│   ├── utils/               # ユーティリティ関数
│   └── styles/              # グローバルスタイル
├── public/                  # 静的ファイル
├── package.json
└── next.config.js
```

### 命名規則

- **ファイル名**: kebab-caseを使用します（例：`post-settings.tsx`、`user-profile.tsx`）。
- **コンポーネント名**: PascalCaseを使用します（例：`PostSettings`、`UserProfile`）。
- **関数名・変数名**: camelCaseを使用します（例：`getPostLogs`、`isLoading`）。
- **定数名**: UPPER_SNAKE_CASEを使用します（例：`MAX_POST_LENGTH`、`API_BASE_URL`）。
- **型名・インターフェース名**: PascalCaseを使用します（例：`PostData`、`ApiResponse`）。

### コンポーネント設計

- **Server Components**: デフォルトでServer Componentsを使用します。
- **Client Components**: インタラクティブな機能（`useState`、`useEffect`など）が必要な場合のみ`'use client'`ディレクティブを使用します。
- **コンポーネント分割**: 1つのコンポーネントは1つの責任を持つようにします。
- **再利用性**: 共通のUI要素は`components/ui/`に配置します。

### TypeScript

- `strict`モードを有効にします。
- `any`型の使用は避け、適切な型定義を行います。
- 型定義は`types/`ディレクトリに集約します。
- インターフェースとタイプエイリアスを適切に使い分けます。

### スタイリング

- Tailwind CSSを使用してスタイリングを行います。
- カスタムクラスは`globals.css`の`@layer components`で定義します。
- インラインスタイルは使用しません（Tailwindクラスを使用）。
- レスポンシブデザインを考慮します（`sm:`、`md:`、`lg:`などのブレークポイントを使用）。

### 状態管理

- グローバル状態はZustandを使用します。
- ローカル状態は`useState`を使用します。
- サーバー状態はReact Query（必要に応じて）を使用します。

### API通信

- API通信は`utils/api.ts`に集約します。
- エラーハンドリングを適切に実装します。
- ローディング状態を適切に管理します。

### エラーハンドリング

- エラーバウンダリーを実装します。
- エラーメッセージはユーザーに分かりやすく表示します。
- 開発環境では詳細なエラー情報を表示します。

### パフォーマンス

- 画像は`next/image`コンポーネントを使用します。
- 動的インポート（`dynamic`）を適切に使用します。
- 不要な再レンダリングを避けます（`React.memo`、`useMemo`、`useCallback`を適切に使用）。

### 例

```typescript
// ✅ 良い例
'use client'

import { useState, useEffect } from 'react'
import { ApiResponse, PostLog } from '@/types'

interface DashboardProps {
  initialData?: PostLog[]
}

const Dashboard = ({ initialData = [] }: DashboardProps) => {
  const [isLoading, setIsLoading] = useState(false)
  const [postLogs, setPostLogs] = useState<PostLog[]>(initialData)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    const fetchPostLogs = async () => {
      setIsLoading(true)
      setError(null)

      try {
        const response = await fetch('/api/post/logs')
        const data: ApiResponse<PostLog[]> = await response.json()

        if (data.success && data.data) {
          setPostLogs(data.data)
        } else {
          setError(data.error || 'データの取得に失敗しました')
        }
      } catch (err) {
        setError('ネットワークエラーが発生しました')
        console.error('投稿ログ取得エラー:', err)
      } finally {
        setIsLoading(false)
      }
    }

    fetchPostLogs()
  }, [])

  if (isLoading) {
    return <div className="text-center py-8">読み込み中...</div>
  }

  if (error) {
    return (
      <div className="bg-red-50 border border-red-200 rounded-md p-4">
        <p className="text-red-700">{error}</p>
      </div>
    )
  }

  return (
    <div className="min-h-screen bg-gray-50">
      <h1 className="text-3xl font-bold text-gray-900">ダッシュボード</h1>
      {/* ... */}
    </div>
  )
}

export default Dashboard

// ❌ 悪い例
const Dashboard = () => {
  const [data, setData] = useState([])
  
  useEffect(() => {
    fetch('/api/post/logs').then(r => r.json()).then(d => setData(d))
  }, [])
  
  return <div>{data.map(x => <div>{x.content}</div>)}</div>
}
```

## 共通規約

### Git

- コミットメッセージは日本語で記述します。
- コミットメッセージの形式：
  ```
  [種類] 変更内容の簡潔な説明

  詳細な説明（必要に応じて）
  ```
- 種類の例：`[追加]`、`[修正]`、`[削除]`、`[リファクタ]`、`[ドキュメント]`

### コメント

- 日本語でコメントを記述します。
- 複雑なロジックには必ずコメントを付けます。
- JSDocコメントを適切に使用します。

### テスト

- 重要な機能にはテストを書きます。
- テストファイルは`*.test.ts`または`*.spec.ts`という命名規則に従います。

### セキュリティ

- 環境変数に機密情報を保存します。
- SQLインジェクション対策としてプリペアドステートメントを使用します。
- XSS対策として適切なエスケープ処理を行います。
- CORS設定を適切に行います。

## 開発ツール

### ESLint

- プロジェクトルートに`.eslintrc.json`を配置します。
- コミット前にESLintチェックを実行します。

### Prettier

- プロジェクトルートに`.prettierrc.json`を配置します。
- コミット前にPrettierフォーマットを実行します。

### 推奨設定

```json
// .prettierrc.json
{
  "printWidth": 80,
  "tabWidth": 2,
  "useTabs": false,
  "semi": true,
  "singleQuote": true,
  "trailingComma": "es5",
  "bracketSpacing": true,
  "arrowParens": "avoid",
  "endOfLine": "lf"
}
```

## 行動規範

- Node.js、Express.js、Next.js、TypeScript、React、Tailwind CSS、MySQL、AWSのエキスパートとして振る舞います。
- RESTfulな設計原則を遵守します。
- API分離型アーキテクチャを維持し、バックエンドとフロントエンドの責任を明確に分離します。
- 統一されたAPIレスポンス形式を使用します。
- 適切なHTTPステータスコードを返します。
- モダンで直感的なUI/UXの構築を重視します。

## 主要規約まとめ

- **命名規則**: kebab-case（ファイル）、camelCase（変数・関数）、PascalCase（クラス・コンポーネント）
- **コードスタイル**: セミコロン必須、2スペースインデント、シングルクォート
- **エラーハンドリング**: すべての非同期処理で`try-catch`を使用
- **型安全性**: TypeScript strictモード、`any`型の使用を避ける
- **コメント**: 日本語で記述、複雑なロジックには必ずコメント
- **セキュリティ**: 環境変数で機密情報を管理、プリペアドステートメントを使用

---

**最終更新日**: 2025年11月20日  
**バージョン**: 1.0.0

